---
title: ''
author: ''
date: ''
output:
  pdf_document: null
  fig_crop: no
  html_document:
    df_print: paged
subtitle: ''
highlight: tango
number_sections: no
fig_caption: yes
keep_tex: yes
includes:
  in_header: Estilo.sty
classoption: a4paper
always_allow_html: yes
---
  
  
\begin{center}
{\Large
  DEPARTAMENTO DE ESTATÍSTICA} \\
\vspace{0.5cm}
\begin{figure}[!t]
\centering
\includegraphics[width=9cm, keepaspectratio]{logo-UnB.eps}
\end{figure}
\vskip 1em
{\large
  `r format(Sys.time(), '%d %B %Y')`}
\vskip 3em
{\LARGE
  \textbf{Trabalho 2}} \\
\vskip 1em
{\Large
  Profª. Drª. Thais Carvalho Valadares Rodrigues} \\
\vskip 1em
{\Large
  Computação em Estatística 2} \\
\vskip 1em
{\Large
  Aluno: Bruno Gondim Toledo | Matrícula: 15/0167636} \\
\vskip 1em
\end{center}

\vskip 5em

\newpage

\textbf{Instruções}

\textbf{1)} Escreva seu código com esmero, evitando operações redundantes, comentando os resultados e usando as melhores práticas em programação. \textbf{Utilize o pacote purr}.

\vskip 2em


\textbf{2)} O aluno deve enviar 1 arquivo pdf contendo \textbf{ambos}: o código utilizado para realizar cada questão e o resultado obtido (ou as primeiras linhas do resultado obtido, caso o resultado seja extenso), de preferência,
utilizem o Rmarkdown. Além disso, o aluno deve enviar o arquivo .R com o código desenvolvido.

\vskip 2em


\textbf{3)} Os arquivos devem ser enviados pelo Teams até às 23h59 do dia 17/02/2023.

\vskip 2em

\textbf{4)} O trabalho é individual! Respostas semelhantes serão penalizadas severamente.

\newpage

# Questão 1) Com base no banco de dados `nycflights13::flights`, execute os comandos a seguir, a fim de transformar o banco de dados em uma lista por companhia aerea (*carrier*), e responda os itens abaixo utilizando a lista banco e as funcionalidades do pacote purr. `banco <- nycflights13::flights %>% split(.$carrier)`

```{r setup}
if (!require("pacman")) install.packages("pacman")
p_load(knitr,tidyverse,pracma,signal)
banco <- nycflights13::flights %>% split(.$carrier)
```

## a) A partir da lista banco, selecione as colunas que contém a palavra ‘delay’ para cada companhia aerea (*carrier*). Retorne o resultado como uma lista. (1 ponto)

```{r 1a}

lista <- banco %>%
  map(~select(.x, contains("delay")))

head(lista,n=2)

```

\newpage

## b) A partir da lista obtida na letra A, calcule a média dos atrasos de chegada e de saída para cada companhia aerea (*carrier*). Retorne o resultado como um dataframe. (1 ponto)

```{r 1b}

dataframe <- lista %>%
  map_dfr(~ data.frame(
    mean_dep_delay  = mean(.x$dep_delay,na.rm = T),
    mean_arr_delay = mean(.x$arr_delay,na.rm = T))
    )

dataframe

```

\newpage

## c) Crie uma função para repetir a tarefa da letra B, mas permita ao usuário escolher a operação que será efetuada nas colunas (média, mínimo, *summary*, etc . . . ). Permita ao usuário escolher se `na.rm = T/F`. Retorne o resultado como uma lista. (1 ponto)

```{r 1c}

funcao <- function(operacao=mean,na=T){
  lista2 <- lista %>%
  map(~list(mean_dep_delay  = operacao(.x$dep_delay,na.rm = na),
        mean_arr_delay = operacao(.x$arr_delay,na.rm = na)))
  return(lista2)
}

funcao()
funcao(operacao=summary,na=F)

# Mais exemplos de operação da função no arquivo .R;
# suprimido aqui para não poluir demais o documento!

```

\newpage

## d) A partir da lista inicial banco, faça um *boxplot* da coluna `‘arr_delay’` para cada companhia aérea (utilize as funções `map` e `boxplot`). (1 ponto)

```{r 1d}

lista3 <- banco %>%
  map(~select(.x, contains("arr_delay"))) %>%
  map(~boxplot(.))

```

\newpage

## e) Note que, além do gráfico, a função `boxplot` retorna uma série de informações relevantes. Com base nisso, retorne quantos outliers na variável `‘arr_delay’` cada companhia aérea registrou. Retorne o resultado como um vetor. (1 ponto)

```{r 1e}

outliers <- lista3 %>%
  map(~.$out) %>%
  map(as.data.frame)

quantidade_outliers <- outliers %>%
  map_int(nrow) %>%
  unlist()

quantidade_outliers

```

\newpage

# Questão 2) Construa uma função para calcular as raízes de um polinômio de grau 3. Caso hajam duas raízes iguais, lançar uma mensagem de aviso para notificar o usuário. Permita ao usuário a opção de que o grafico da função seja construído e as raízes identificadas. Use o elemento ... para dar ao usuário controle dos parâmetros do gráfico. Por fim, teste sua função com alguns exemplos interessantes. (3 ponto)


```{r 2}

pol3 <- function(a,b,c,d,grafico=T,resultado=T, ...){
  raizes <- roots(c(a,b,c,d))
  lista_return <- list()
  lista_return[[1]] <- raizes
  if (length(unique(raizes)) != length(raizes)){
    lista_return[[2]] <- "Existem raízes iguais"}
  if (grafico==T & resultado==T){
    x <- seq(-10,10,length=200)
    plot(x,polyval(poly(raizes),x), ...)
    return(lista_return)
  }
  else if (grafico==T & resultado==F){
    x <- seq(-10,10,length=200)
    plot(x,polyval(poly(raizes),x), ...)
  }
  else if(grafico==F & resultado==T){
    return(lista_return)
  }
  else {
    return("Girafas são criaturas sem coração")
  }
}

pol3(1,1,1,1)
pol3(6,11,6,1)
pol3(1,11,6,1)

pol3(1,3,3,1,grafico=F)



pol3(1,1,1,1,grafico =T ,resultado =T )
pol3(1,1,1,1,grafico =T ,resultado =F )
pol3(1,1,1,1,grafico =F ,resultado =T )
pol3(1,1,1,1,grafico =F ,resultado =F )

pol3(1,1,1,1, type='l')

pol3(1,16,1,1)

pol3(1,5,1,1,grafico=F)

pol3(11,16,14,12, type='l',lwd='2')

```

\newpage

# Questão 3) Com relação ao tópico do trabalho final do seu grupo, escreva sobre a utilidade do tema e explique 1 função interessante do pacote utilizado. (2 ponto)

Webscrapping, ou raspagem de dados, pode ser extremamente útil na vida do estatístico, cientista de dados ou qualquer um que queira manipular dados em *html*.

Basicamente, estamos acostumados a trabalhar com bancos de dados tabulados em formatos como *.csv*, *.xlsx* e até *.txt*, seja pelo `R`, seja utilizando outra ferramenta. Porém, as vezes queremos trabalhar com dados, especialmente aqueles disponíveis em sites, muitas vezes de nichos específicos e que não existe a opção de baixar ou obter os dados diretamente em formato de *excel* ou similar. Porém, utilizando técnicas de raspagem de dados, este impeditivo se torna facilmente superável.

Trabalhando com o `R`, dispomos de pacotes como o `selenium`, ou, como mostraremos em nossa apresentação, o pacote `rvest`, em conluio com o pacote `xml2`, que nos será útil na rotina de raspagem de dados da internet. 

Com certeza, as funções mais auspciosas desses pacotes são a `rvest::html_nodes` ou `rvest::html_elements`, que servirão justamente para captar da marcação *html* as informações que gostaríamos de extrair em formato de texto ou numérico para enfim os manipular conforme vontade/necessidade.

É muito comum utilizar raspagem de dados para, por exemplo, fazer pesquisas de preços em sites que dispoem seu catálogo de produtos em formato *html* (basicamente quase todos os sites comerciais). Além disso, tem se popularizado o uso para coletar *tweets* da conta do *twitter* de determinadas pessoas, a fim de se fazer a análise desejável (text mining, núvem de palavras, etc).